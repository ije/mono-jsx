import { build, stop, transform } from "https://deno.land/x/esbuild@v0.25.10/mod.js";
import pkgJson from "./package.json" with { type: "json" };

async function buildRuntime(name: string): Promise<string> {
  const ret = await build({
    entryPoints: [`./runtime/${name}.ts`],
    platform: "browser",
    format: "esm",
    target: "es2022",
    minify: true,
    write: false,
  });
  if (ret.errors.length > 0) {
    throw new Error(ret.errors[0].text);
  }
  return ret.outputFiles[0].text.trim();
}

async function buildChunk(filename: string, exportName: string): Promise<string> {
  const ret = await build({
    stdin: {
      contents: `export { ${exportName} } from "./runtime/${filename}";`,
      resolveDir: "./",
    },
    platform: "browser",
    format: "esm",
    target: "es2022",
    bundle: true,
    minify: true,
    write: false,
  });
  if (ret.errors.length > 0) {
    throw new Error(ret.errors[0].text);
  }
  return ret.outputFiles[0].text.trim().replace(/export\{(\w+) as (\w+)\};$/, "window.$" + exportName + "=$1;");
}

async function buildPackageModule(name: string, format: "esm" | "cjs" = "esm") {
  const entryPointPath = `./${name}.ts`;
  const outfile = `./${name}.` + (format === "esm" ? "mjs" : "cjs");
  await build({
    entryPoints: [entryPointPath],
    outfile,
    format,
    target: "esnext",
    bundle: true,
    minify: false,
    external: ["node:*", "*.mjs"],
  });
  const gzippedSize = await getGzippedSize(await Deno.readTextFile(outfile));
  return {
    size: (await Deno.lstat(outfile)).size,
    gzippedSize,
  };
}

async function getGzippedSize(code: string, minify: boolean = true): Promise<number> {
  if (minify) {
    code = (await transform(code, {
      loader: "js",
      platform: "browser",
      format: "esm",
      target: "es2022",
      minify: true,
    })).code;
  }
  const readableStream = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(code));
      controller.close();
    },
  });
  const res = new Response(readableStream.pipeThrough(new CompressionStream("gzip")));
  const buffer = await res.arrayBuffer();
  return buffer.byteLength;
}

function formatBytes(bytes: number): string {
  return bytes.toLocaleString() + "B";
}

if (import.meta.main) {
  const eol = "\n";
  const start = performance.now();
  const binJS = [
    `#!/usr/bin/env node`,
    ``,
    `import process from "node:process";`,
    `import { setup } from "../setup.mjs";`,
    ``,
    `switch (process.argv[2]) {`,
    `  case "setup":`,
    `    setup()`,
    `    break;`,
    `  default:`,
    `    process.exit(0);`,
    `}`,
    ``,
  ].join(eol);
  const eventJS = [
    `var w=window;`,
    `w.$emit=(e,f,s)=>f.call(w.$signals?.(s)??e.target,e.type==="mount"?e.target:e);`,
    `w.$onsubmit=(e,f,s)=>{e.preventDefault();f.call(w.$signals?.(s)??e.target,new FormData(e.target),e)};`,
  ].join("");
  const runtimeJS = {
    "event.js": await Promise.resolve(eventJS),
    "cx.js": await buildChunk("utils.ts", "cx"),
    "style.js": await buildChunk("utils.ts", "applyStyle"),
    "render_attr.js": await buildChunk("render.ts", "renderAttr"),
    "render_toggle.js": await buildChunk("render.ts", "renderToggle"),
    "render_switch.js": await buildChunk("render.ts", "renderSwitch"),
    "signals.js": await buildRuntime("signals"),
    "suspense.js": await buildRuntime("suspense"),
    "component.js": await buildRuntime("component"),
    "router.js": await buildRuntime("router"),
    "form.js": await buildRuntime("form"),
  };

  await Deno.writeTextFile(
    "./runtime/index.ts",
    [
      "// generated by build.ts, do not edit",
      "",
      "// runtime flags",
      ...Object.entries(runtimeJS).map(([name], i) => {
        const exportName = name.replace(/([a-z])([A-Z])/g, "$1_$2").replace(".js", "").toUpperCase();
        return `export const ${exportName} = ` + (1 << i) + ";";
      }),
      "",
      ...Object.entries(runtimeJS).map(([name, js]) => {
        const exportName = name.replace(/([a-z])([A-Z])/g, "$1_$2").replace(".", "_").toUpperCase();
        const comment = `/** ${name} (${formatBytes(js.length)}) */`;
        console.log(`· *${name} %c(${formatBytes(js.length)})`, "color:grey");
        return comment + eol + `export const ${exportName} = \`{${js}}\`;` + eol;
      }),
    ].join(eol),
  );

  for (const moduleName of ["setup", "index", "jsx-runtime", "dom/index", "dom/jsx-runtime"]) {
    const { size, gzippedSize } = await buildPackageModule(moduleName, "esm");
    console.log(`· ${moduleName}.mjs %c(${formatBytes(size)}, ${formatBytes(gzippedSize)} gzipped)`, "color:grey");
  }

  await Deno.writeTextFile("./version.ts", `export const VERSION = "${pkgJson.version}";` + eol);

  await Deno.mkdir("./bin", { recursive: true });
  Deno.writeTextFile("./bin/mono-jsx", binJS, { mode: 0o755 });

  console.log("%cBuild complete! (%d ms)", "color:grey", performance.now() - start);
  stop();
}
