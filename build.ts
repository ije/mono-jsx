import { build, stop } from "https://deno.land/x/esbuild@v0.25.0/mod.js";

async function buildRuntime(name: string): Promise<string> {
  const ret = await build({
    entryPoints: [`./runtime/${name}.ts`],
    format: "esm",
    target: "es2022",
    write: false,
    minify: true,
  });
  if (ret.errors.length > 0) {
    throw new Error(ret.errors[0].text);
  }
  return ret.outputFiles[0].text.trim();
}

async function buildRuntimeUtils(name: string): Promise<string> {
  const ret = await build({
    stdin: {
      contents: `export { ${name} } from "./runtime/utils.ts";`,
      resolveDir: "./",
    },
    format: "esm",
    target: "es2022",
    write: false,
    bundle: true,
    minify: true,
  });
  if (ret.errors.length > 0) {
    throw new Error(ret.errors[0].text);
  }
  return ret.outputFiles[0].text.trim().replace(/export\{(\w+) as (\w+)\};$/, "window.$" + name + "=$1;");
}

async function buildPackageModule(name: string, format: "esm" | "cjs" = "esm") {
  const entryPointPath = `./${name}.ts`;
  const outfile = `./${name}.` + (format === "esm" ? "mjs" : "cjs");
  await build({
    entryPoints: [entryPointPath],
    outfile,
    format,
    target: "esnext",
    minify: false,
    bundle: true,
    external: ["node:*"],
  });
  return await Deno.lstat(outfile);
}

function stringLit(str: string): string {
  return "`" + str + "`";
}

if (import.meta.main) {
  const start = performance.now();
  const state_js = await buildRuntime("state");
  const suspense_js = await buildRuntime("suspense");
  const cx_js = await buildRuntimeUtils("cx");
  const styleToCSS_js = await buildRuntimeUtils("styleToCSS");
  const event_js = [
    `var w=window;`,
    `w.$emit=(e,fn,fc)=>fn.call(w.$this?.(fc)??e.target,e);`,
    `w.$onsubmit=(e,fn,fc)=>{e.preventDefault();fn.call(w.$this?.(fc)??e.target,new FormData(e.target),e)};`,
    `w.$onstage=()=>document.querySelectorAll("[onmount]").forEach(t=>{const k="onmount",j=t.getAttribute(k);t.removeAttribute(k);new Function("event",j)({type:"mount",target:t})});`,
  ].join("");

  await Deno.writeTextFile(
    "./runtime/index.ts",
    [
      `// generated by build.ts, do not edit`,
      ``,
      `/** state.js (${state_js.length} bytes) */`,
      `export const STATE_JS = ${stringLit(state_js)};`,
      ``,
      `/** suspense.js (${suspense_js.length} bytes) */`,
      `export const SUSPENSE_JS = ${stringLit(suspense_js)};`,
      ``,
      `/** utils */`,
      `export const UTILS_JS = {`,
      `  /** cx.js (${cx_js.length} bytes) */`,
      `  cx: ${stringLit(cx_js)},`,
      `  /** styleToCSS.js (${styleToCSS_js.length} bytes) */`,
      `  styleToCSS: ${stringLit(styleToCSS_js)},`,
      `  /** event.js (${event_js.length} bytes) */`,
      `  event: ${stringLit(event_js)}`,
      `};`,
      ``,
    ].join("\n"),
  );
  console.log(`· STATE_JS %c(${state_js.length} bytes)`, "color:grey");
  console.log(`· SUSPENSE_JS %c(${suspense_js.length} bytes)`, "color:grey");

  for (const moduleName of ["index", "jsx-runtime", "setup"]) {
    const { size } = await buildPackageModule(moduleName, "esm");
    console.log(`· ${moduleName}.mjs %c(${size.toLocaleString()} bytes)`, "color:grey");
  }

  await Deno.mkdir("./bin", { recursive: true });
  Deno.writeTextFile(
    "./bin/mono-jsx",
    [
      `#!/usr/bin/env node`,
      ``,
      `import process from "node:process";`,
      `import { setup } from "../setup.mjs";`,
      ``,
      `switch (process.argv[2]) {`,
      `  case "setup":`,
      `    setup()`,
      `    break;`,
      `  default:`,
      `    process.exit(0);`,
      `}`,
      ``,
    ].join("\n"),
    { mode: 0o755 },
  );

  console.log("%cBuild complete! (%d ms)", "color:grey", performance.now() - start);
  stop();
}
